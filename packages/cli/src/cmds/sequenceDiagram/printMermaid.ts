import assert from 'assert';
import { Event, CodeObject as AppMapCodeObject } from '@appland/models';

import { SequenceGraph } from './graph';
import { classNameToOpenAPIType } from '@appland/openapi';
import { basename, join, resolve } from 'path';
import { mkdir, writeFile } from 'fs/promises';
import { CallEdge, isCallEdge, ReturnEdge } from './edge';

const MarkdownDelimiter = '```';
const DisplayCharLimit = 50;

const DisplayNames = {
  'http:HTTP server requests': 'Web server',
};

export function displayName(fqid: string): string {
  if (DisplayNames[fqid]) return DisplayNames[fqid];

  let tokens = fqid.split(':');
  tokens.shift();
  let name = tokens.join(':');
  if (name.includes('/')) name = name.split('/').pop()!;

  return name;
}

export function formatMessage(message: string, messageType?: string) {
  if (messageType === 'struct') return message;

  const type = classNameToOpenAPIType(messageType);

  if (type === 'object') {
    return `a ${messageType}`;
  } else if (type === 'array') {
    return `an array`;
  } else if (type) {
    return `a ${type}`;
  } else {
    return message.slice(0, DisplayCharLimit);
  }
}

export default async function printMermaid(
  outputDir: string,
  graph: SequenceGraph,
  argv: string[],
  matchingCodeObjectOfEvent: (event: Event) => AppMapCodeObject | undefined,
  priorityOf: (codeObjectId: string) => number
): Promise<string> {
  const uniqueIds = new Set<string>();
  const actors: { name: string; displayName: string; priority: number }[] = [];
  const linkLines: string[] = [];

  const encode = (str: string) => {
    let printable = str;
    const match = str.match(/<#?([^>\]]+)[>\]]/);
    if (match) printable = match[1];
    return printable.replace(/[\u00A0-\u9999<>\&]/g, function (i) {
      return '&#' + i.charCodeAt(0) + ';';
    });
  };
  const alias = (id: string) => id.replace(/[^a-zA-Z0-9]/g, '_');
  const actor = (event: Event): AppMapCodeObject => {
    const co = matchingCodeObjectOfEvent(event);
    if (!co)
      throw assert(co, `Event code object ${event.codeObject.fqid} not found`);
    return co;
  };
  const collectActor = (event: Event) => {
    const id = actor(event).fqid;
    if (!uniqueIds.has(id)) {
      uniqueIds.add(id);
      const priority = priorityOf(id);
      actors.push({ name: id, displayName: displayName(id), priority });
      const url = `vscode://open?uri=${resolve(
        process.cwd(),
        graph.appmapFile
      )}.appmap.json`;
      linkLines.push(`links ${alias(id)}: ${JSON.stringify({ AppMap: url })}`);
    }
  };
  const callArrow = (edge: CallEdge): string =>
    edge.hasResponse ? '->>+' : '->>';
  const returnArrow = (edge: ReturnEdge): string | undefined =>
    edge.message || edge.exceptions ? '-->>-' : undefined;
  const edgeArrow = (edge: CallEdge | ReturnEdge): string | undefined =>
    isCallEdge(edge) ? callArrow(edge) : returnArrow(edge as ReturnEdge);

  graph.edges.forEach((edge) => {
    collectActor(edge.caller);
    collectActor(edge.callee);
  });
  const eventLines = graph.edges
    .map((edge) => {
      const { message, messageType } = edge;
      const arrow = edgeArrow(edge);
      if (!arrow || !message) return;

      return [
        [alias(actor(edge.caller).fqid), alias(actor(edge.callee).fqid)].join(
          arrow
        ),
        encode(formatMessage(message, messageType)),
      ].join(': ');
    })
    .filter(Boolean);
  const template = `${MarkdownDelimiter}mermaid
%% Generated by: ${argv.join(' ')}
%% AppMap: ${graph.appmapFile}.appmap.json
sequenceDiagram
${actors
  .sort((a, b) => a.priority - b.priority)
  .map(
    (actor) =>
      `participant ${alias(actor.name)} as ${encode(actor.displayName)}`
  )
  .join('\n  ')}
${linkLines.join('\n  ')}
${eventLines.join('\n  ')}
${MarkdownDelimiter}`;
  await mkdir(outputDir, { recursive: true });
  await writeFile(
    join(outputDir, [basename(graph.appmapFile), 'md'].join('.')),
    template
  );
  return template;
}
