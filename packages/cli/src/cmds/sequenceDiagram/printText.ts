import assert from 'assert';
import { Event, CodeObject as AppMapCodeObject } from '@appland/models';

import { SequenceGraph } from './graph';
import { basename, join, resolve } from 'path';
import { mkdir, writeFile } from 'fs/promises';
import { CallEdge, isCallEdge, ReturnEdge } from './edge';
import { formatMessage } from './printMermaid';

export default async function printText(
  outputDir: string,
  graph: SequenceGraph,
  argv: string[],
  matchingCodeObjectOfEvent: (event: Event) => AppMapCodeObject | undefined,
  priorityOf: (codeObjectId: string) => number
): Promise<string> {
  const uniqueIds = new Set<string>();
  const actors: { id: string; priority: number }[] = [];

  const encode = (str: string) => {
    let printable = str;
    const match = str.match(/<#?([^>\]]+)[>\]]/);
    if (match) printable = match[1];
    return printable.replace(/:0x.*/, ' instance');
  };
  const actor = (event: Event): AppMapCodeObject => {
    const co = matchingCodeObjectOfEvent(event);
    if (!co)
      throw assert(co, `Event code object ${event.codeObject.fqid} not found`);
    return co;
  };
  const collectActor = (event: Event) => {
    const id = actor(event).fqid;
    if (!uniqueIds.has(id)) {
      uniqueIds.add(id);
      const priority = priorityOf(id);
      actors.push({ id, priority });
    }
  };
  const callArrow = (edge: CallEdge): string =>
    edge.hasResponse ? '->>+' : '->>';
  const returnArrow = (edge: ReturnEdge): string | undefined =>
    edge.message || edge.exceptions ? '-->>-' : undefined;
  const edgeArrow = (edge: CallEdge | ReturnEdge): string | undefined =>
    isCallEdge(edge) ? callArrow(edge) : returnArrow(edge as ReturnEdge);

  graph.edges.forEach((edge) => {
    collectActor(edge.caller);
    collectActor(edge.callee);
  });
  const eventLines = graph.edges
    .map((edge) => {
      const { message, messageType } = edge;
      const arrow = edgeArrow(edge);
      if (!arrow || !message) return;

      return [
        [actor(edge.caller).fqid, actor(edge.callee).fqid].join(arrow),
        encode(formatMessage(message, messageType)),
      ].join(': ');
    })
    .filter(Boolean);
  const template = `%% Generated by: ${argv.join(' ')}
%% AppMap: ${graph.appmapFile}.appmap.json
${actors
  .sort((a, b) => a.priority - b.priority)
  .map((actor) => `participant ${actor.id}`)
  .join('\n  ')}
${eventLines.join('\n  ')}
`;
  await mkdir(outputDir, { recursive: true });
  await writeFile(
    join(outputDir, [basename(graph.appmapFile), 'txt'].join('.')),
    template
  );
  return template;
}
